## snowflake



分布式自增id算法



### 1) 简介

`snowflake` 是 `Twitter`开源的分布式ID生成算法，结果是一个long型的ID( 64bits )。其核心思想是：

```js
41bit 作为毫秒数，

10bit 作为机器的ID（5个bit是数据中心，5个bit的机器ID），

12bit 作为毫秒内的序列号(sequence)（意味着每个节点在每毫秒可以产生 4096 个 ID），

最后还有 1bit 作为符号位，永远是0。
```



![image-20210506155557012](./snowflake.png)



### 2) 优点

```js
1.快
2.没有啥依赖，实现也特别简单。
3.方便灵活。
```

比如 `10 bits` 的 `machineID` 可以自由进行拆分, 一般来说可以拆成 `3bits` 的数据中心id , `7bits` 的机器id



### 3) 缺点

```js
1. 只能趋势递增。
2. 依赖机器时间，如果发生回拨会导致可能生成id重复
```





### 4) 实现步骤

```js
1. 获取当前的毫秒时间戳；
2. 用当前的毫秒时间戳和上次保存的时间戳进行比较；
			如果和上次保存的时间戳相等，那么对序列号 sequence 加一；
			如果不相等，那么直接设置 sequence 为 0 即可；
然后通过或运算拼接雪花算法需要返回的 int64 返回值。
```





### 5) 代码地址

https://github.com/sado0823/go-snowflake

```go
func (s *Snowflake) NextVal() (int64, error) {
	s.Lock()
	defer s.Unlock()
	now := time.Now().UnixNano() / 1000000 // 转毫秒
	if s.timestamp == now {
		// 当同一时间戳（精度：毫秒）下多次生成id会增加序列号
		s.sequence = (s.sequence + 1) & sequenceMask
		if s.sequence == 0 {
			// 如果当前序列超出12bit长度，则需要等待下一毫秒
			// 下一毫秒将使用sequence:0
			for now <= s.timestamp {
				now = time.Now().UnixNano() / 1000000
			}
		}
	} else {
		// 不同时间戳（精度：毫秒）下直接使用序列号：0
		s.sequence = 0
	}
	t := now - s.epoch
	if t > timestampMax {
		return 0, fmt.Errorf("epoch must be between 0 and %d", timestampMax-1)
	}
	s.timestamp = now
	r := (t)<<timestampShift | (s.sequence)
	return r, nil
}
```



### 附: 位运算

与 ( & )

```js
& 与：只有当两位都是 1 时结果才是 1，否则为 0 。

0110 & 0100 ----------- 0100
```



或 ( | )

```js
| 或：两位中只要有 1 位为 1 结果就是 1，两位都为 0 则结果为 0。

0110 & 0110 ----------- 0110
```



异或 ( ^ )

```js
^ 异或：两个位相同则为 0，不同则为 1

0110 ^ 0100 ----------- 0010
```



取反 ( ~ )

```js
~ 取反：0 则变为 1，1 则变为 0

~ 0110 ----------- 1001
```



左移 ( << )

```js
<< 左移：向左进行移位操作，高位丢弃，低位补 0

int a = 8; a << 3; 
移位前：00000000000000000000000000001000 
移位后：00000000000000000000000001000000

8 * 2^3 = 48
```



右移 ( >> )

```js
>> 右移：向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位

unsigned int a = 8; a >> 3; 
移位前：00000000000000000000000000001000 
移位后：00000000000000000000000000000001 

8 / 2^3 = 1

int a = -8; a >> 3; 
移位前：11111111111111111111111111111000 
移位后：11111111111111111111111111111111

-8 / 2^3 = -1
```

